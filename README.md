# k-means clusterization

Реализация на прост, но мощен алгоритъм за клъстеризация на 2D точки, представени като наредени двойки `(Double,Double)`. Използвани са прости и оптимални за повечето цели структури от данни, които се обхождат итеративно, избягва се търсене в големи списъци, някои изчисления са стриктни и т.н. Допълнително се измерва общото време за работата на програмата (вкл. IO операциите, парсването на входа и форматирането на изхода), както и след колко итерации е приключил алгоритъма. Необходим е пакетът [`clock`](https://hackage.haskell.org/package/clock) за точно отмерване на времето (без него кодът, естествено, не се компилира).

Може би най-съществената хитринка е във функцията `reClusterize`, която с _едно_ линейно итеративно и стриктно обхождане на пълния списък от точки изчислява за всяка от тях кой е новият ѝ клъстер, и по същото време следи дали някоя си го променя, и връща тази информация като `Bool` в наредена двойка със получения списък от точки. От друга страна, функцията `groupToClusters` може да се подобри значително, тъй като също се извиква по веднъж на всяка итерация, а блести по-скоро с простота, отколкото с ефективност.

Единственият реален недостатък е, че в момента първоначалните центрове се определят детерминистично (а не на произволен принцип), което значи че при един и същи вход програмата ще достига до един и същ, може би локален, минимум. Би било полезно да се връща и стойността на този достигнат минимум, за да може да се прецени кой избор на първоначални центрове води до по-добра клъстеризация.

Кодът е предназначен да се компилира до executable, който при стартиране получава три аргумента:
* име на файл в входните данни - текстови файл, в който всеки ред съдържа координатите на една точка, разделени с празно място (вж. [`input1250.txt`](https://github.com/Andreshk/k-means/blob/master/input1250.txt) за пример)
* брой търсени клъстери
* име на файл за изходните данни - резултата от клъстеризирането.

Аргументите не се валидират, следи се единствено техния брой (поне три, всички след третия се игнорират).

Файлът [`input1250.txt`](https://github.com/Andreshk/k-means/blob/master/input1250.txt) служи за примерен вход и съдържа 1249 точки, без никаква особена вътрешна структура (любезно предоставен с цел тестване от @zaki1993). На моя неособен лаптоп клъстеризирането им в 4 клъстера отнема 35 итерации и ~0,4 секунди, а в 10 клъстера - 22 итерации, но около 0,7 секунди.
